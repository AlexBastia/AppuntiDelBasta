\chapter{Bottom up parser}

Il \textbf{parser bottom up} è un tipo di analizzatore sintattico che che costruisce l'albero di derivazione partendo dalle foglie, viene anche detto \textbf{Shift-Reduce} in quanto possiede due operazioni fondamentali:
\begin{itemize}
    \item \texttt{Shift}: un simbolo terminale viene spostato dall'input alla pila 
    \item \texttt{Reduce}: una serie di simboli (terminali e non terminali) sulla cima della pila corrisponde al "reverse" di una parte destra di una produzione, ovvero:
    \[
        A\to\alpha \in R - \alpha^R \text{ sulla pila}
    \]
    La stringa $\alpha^T$ viene rimossa dalla pila e sostituita con $A$, quindi $\alpha$ viene ridotta ad $A$
\end{itemize}

Possono essere di diversi tipi

\section{Parser shift-reduce nondeterministico}
\begin{algorithm}
    \caption{Parser shift-reduce nondeterministico}
    \KwIn{Una grammatica libera $G$ con simbolo iniziale $S$ e una stringa $w\in T^*$}
    \KwOut{Una stringa $w\in T^*$}

    Inizializziamo la pila a $\$$\;
    Inizializziamo l'input con $w\$$\;
    usaimo il $PDA$ seguente per trovare la derivazione per $w\$$:
    \[
        M=(T, \{q\},\underbracket{T\cup NT \cup \{\$\}}_{\Gamma: \text{ovvero i simboli sulla pila}}, \delta, \varnothing)
    \]
    Dove:
    \begin{enumerate}
        \item $(q,aX)\in \delta (q,a,X)\forall A\in T\forall X\Gamma\quad \text{SHIFT}$
        \item $(q,A)\in\delta(q,\epsilon, \alpha^R)$ se $A\in \alpha\in R\quad \text{REDUCE}$
        \item $(q,\epsilon)\in \delta(q,\$,S\$)\quad \text{accept}$
    \end{enumerate}\;
    ogni volta che facciamo "reduce", forniamo in output la produzione usata\;
    alla fine, $S\$$ sulla pila, con $\$$ in input $\implies$ accettiamo\;
\end{algorithm}

\nt{
    generalizzazione della def. di $PDA$ dove non si consuma solo il top della pila, ma una serie di caratteri contigui a caminciare dal top
}

\esempio{
    Sia la seguente grammatica
    \[
        \begin{array}{l}
            E\to T\mid T+E \mid T-E\\
            T\to A\mid A*T\\
            A\to a\mid b\mid (E)
        \end{array}
    \]
    \[
        \begin{array}{|c|l|l|l|l|}
        \hline
        \textbf{N.} & \textbf{Pila} & \textbf{Input} & \textbf{Azione} & \textbf{Output} \\ \hline
        1  & \$                  & a+b*b\$              & Shift         &                 \\ \hline
        2  & \$a                & +b*b\$               & Reduce        & A \to a         \\ \hline
        3  & \$A                & +b*b\$               & Reduce        & T \to A         \\ \hline
        4  & \$T                & +b*b\$               & Shift         &                 \\ \hline
        5  & \$T+               & b*b\$                & Shift         &                 \\ \hline
        6  & \$T+b              & *b\$                 & Reduce        & A \to b         \\ \hline
        7  & \$T+A              & *b\$                 & Shift         &                 \\ \hline
        8  & \$T+A*             & b\$                  & Shift         &                 \\ \hline
        9  & \$T+A*b            & \$                   & Reduce        & A \to b         \\ \hline
        10 & \$T+A*B            & \$                   & Reduce        & T \to A * T     \\ \hline
        11 & \$T+A*T            & \$                   & Reduce        & E \to T + T     \\ \hline
        12 & \$E                & \$                   & Reduce        & E \to T + T     \\ \hline
        13 & \$E                & \$                   & Accept        &                 \\ \hline
        \end{array}
    \]

    Si ha che:
    \[
        E\implies T+E\implies T+T \implies T + A* T \implies T+A*A \implies T + A * b \implies T + b * b \implies A + b*b  \implies a + b*b
    \]

    Il cui albero è:
    \begin{center}
        \begin{tikzpicture}
            \Tree [
                .E
                [
                    .T
                    [
                        .A
                        [
                            .a
                        ]
                    ]
                ]
                [
                    .+
                ]
                [
                    .E
                    [
                        .T
                        [
                            .A
                            [
                                .b
                            ]
                        ]
                        [
                            .*
                        ]
                        [
                            .T
                            [
                                .A
                                [
                                    .b
                                ]
                            ]
                        ]
                    ]
                ]
            ]
        \end{tikzpicture}
    \end{center}
    
    Le cui proprietà sono:
    \begin{center}
        \item Costruzione dell'albero di derivazione \texttt{bottom-up}    
        \item Derivazione canonica a destra a rovescio
        \item forte non-determinismo:
        \begin{itemize}
            \item \textbf{conflitti shift-reduce}:
            \begin{itemize}
                \item $\$a \quad +b*b\$ \quad \text{shift}$
                \item $\$ a+ \quad b*b \$$
            \end{itemize}
            \item \textbf{Conflitti reduce-reduce}
            \begin{itemize}
                \item $\$T+A*T\quad\$$ reduce $E\to T$
                \item $\$T+A*E\quad\$$
            \end{itemize}
        \end{itemize}
    \end{center}
}

\nt{Si noti quindi che questo tipo parser genera moltissimi confilitti, in diverse sistuazioni era appunto possibile scegliere strade che non portano a riconoscere la stringa. F}

Per "risolvere" tale nondeterminismo occorre fornire al PDA una tabella parsing (struttura di controllo) che "aiuti" a scegliere l'azione giusta, ed è grazie all'uso di questa che nascono i cosiddetti \textbf{parser LR}

\section{Parser LR}
\dfn{Parser LR}{
    Il \textbf{parser LR} è un tipo di analizzatore sintattico che utilizza un approccio bottom-up per analizzare un input e verificare se appartiene al linguaggio generato da una grammatica libera. Il termine LR indica che:
    \begin{itemize}
        \item L: sta per \textit{left-to-right}: l'analisi dell'input avviene da sinistra a destra
        \item R: sta per \textit{Rightmost derivation}: l'analisi ricostruisce una derivazione più a destra in senso inverso
    \end{itemize}
}

Presento, qui uno schema bellino bellino:

%TODO DA FARE QUESTA GIGAMINCHIATA
\begin{center}
    \begin{tikzpicture}
        % Input
        \node at (-2.5, 3.5) {Input:};
        \node[stack] (input1) at (-1,0) {$a_1$};
        \node[stack, right of=input1] (input2) {$a_2$};



        % \node[stack] (input2) at (0,1) {$a_2$};
        % \node[stack] (dots) at (1, 2) {$\dots$};
        % \node[stack] (inputn) at (2,3) {$a_i$};
        % \node[stack] (end) at (3, 4) {$\dots$};
        % \node[stack] (end) at (4, 5) {$a_k$};
        % \node[stack] (end) at (5, 6) {$\$$};
    
        % Parser LR block
        \node[block] (parserLR) at (0,1.5) {Parser LR};
    
        % Output
        \node at (4.5, 1.5) {Output:};
        \node[align=center] (output) at (6.7,1.5) {Derivazione \\ \textit{rightmost} \\ = albero di derivazione};
    
        % Parsing Table
        \node[block] (table) at (0,-1.5) {Tabella di Parsing $M$ \\ \vspace{0.2cm} \textbf{Azione} (Shift/Reduce) \\ sui Terminali \\ \textbf{GOTO} sui Nonterminali};
    
        % Stack
        \node at (-4.2, 1.5) {Pila:};
        \node[stack] (stack0) at (-3.5,1.5) {$S_0$};
        \node[stack] (stackdots) at (-3.5,0.7) {$\vdots$};
        \node[stack] (stackn) at (-3.5,-0.1) {$S_m$};
    
        \node at (-4.2, -1.5) {Pila simboli:};
        \node[stack] (symbol0) at (-3.5,-1.5) {$X_0$};
        \node[stack] (symboldots) at (-3.5,-2.3) {$\vdots$};
        \node[stack] (symboln) at (-3.5,-3.1) {$X_m$};
    
        % Arrows
        \draw[arrow] (input1.south) -- (parserLR.north);
        \draw[arrow] (parserLR.south) -- (table.north) node[midway,right] {consulta};
        \draw[arrow] (parserLR.east) -- (output.west);
    
        \draw[arrow] (stack0.east) ++(0.2,0) -- (parserLR.west);
        \draw[arrow] (symbol0.east) ++(0.2,0) -- (parserLR.west);
    
        % DFA note
        \node[align=center] at (5,-2) {Generata a partire \\ da un DFA \\ (Automa canonico \\ degli stati \\ \textit{viabili})};
    \end{tikzpicture}    
\end{center}

dove una configurazione di tale parser è:
\[
    (s_0, \dots, s_n, x_1 \dots x_m, a_1 \dots a_k \$)
\]

\nt{
    $x_1 \dots x_m a_1 \dots a_k$ è una stringa intermedia della derivazione canonica destra
}
\subsection{Funzionamento del parsing LR}
il parser LR funzione nel seguente modo:
\begin{enumerate}
    \item Legge lo stato nel top della pila $s_n$ e il simbolo corrente dell'input $a_i$
    \item consulta la tabella di parsing LR $M[s_n, a_i]$
    \begin{itemize}
        \item Se $M[s_n, a_i] = \text{shift}\; s$, allora la nuova configurazione è:
        \[
            (s_0\dots s_n \underline{s}\;, x_1 \dots x_n \underline{a_i}, a_{i+1} \dots a_k \$)
        \]
        \item Se $M[s_n, a_i]= \underline{\text{reduce } A\to B}$, allora la nuova configurazione è
        
        \[
            (s_0 \dots s_{n-r} \underline{s}, x_1 \dots x_{m-r}A, a_i\dots a_k \$)
        \]
        Dove $r=|\beta|$ e $M[s_{n-r}, A]=goto \; \underline{s}$

        Cioè fa tre passi:
        \begin{enumerate}
            \item faccio "pop" di r elementi dai 2 stack
            \item metto A in cima alla pila dei simboli
            \item calcolo il nuovo stato top, guardando 
            \[
                M[s_{n-r}, A] = goto\; s \text{ e metto }s\text{ in cima alla pila degli stati}
            \]
        \end{enumerate}
        \item se $M[s_n, a_i] = accept \implies$ fine!
        \item se $M[s_n, a_i] = "bianco" \implies$ errore!
    \end{itemize}
\end{enumerate}
\esempio{
    Sia $G$ la seguente grammatica:
    \[
        \begin{array}{l}
            S'\to S\\
            Senza\to (S)\\
            S\to ()
        \end{array}
    \]

    % Tabella di Parsing LR(0)
    Assumendo che siamo già forniti di questa \textbf{Tabella di Parsing}

    \[
    \begin{array}{|c|ccc|c|}
    \hline
    \text{Stato} & \multicolumn{3}{c|}{\textbf{Azione}} & \textbf{Goto} \\
    \cline{2-4}
    & ( & ) & \$ & S \\
    \hline
    0 & S2 &  &  & g1 \\
    1 &  &  & \text{Accept} & g3 \\
    2 & S2 & S5 &  &  \\
    3 &  & S4 &  &  \\
    4 & r2 & r2 & r2 &  \\
    5 & r3 & r3 & r3 &  \\
    \hline
    \end{array}
    \]

    \vspace{0.5cm}

    % Seconda tabella: Stato della pila, input, azione e output
    \noindent\textbf{Esecuzione del Parsing}


    \[
        \begin{array}{|l|l|l|c|l|}
        \hline
        \text{Stato della pila} & \text{Stack simboli} & \text{Input} & \text{Azione} & \text{Output} \\
        \hline
        (0 & \varepsilon & (())\$ & S2 & - \\
        (0,2 & ( & ())\$ & S2 & - \\
        (0,2,2 & (( & ))\$ & S5 & - \\
        (0,2,2,5 & (() & )\$ & r3 & S \to () \\
        (0,2,3 & (S & )\$ & S4 & - \\
        (0,2,3,4 & (S) & \$ & r2 & S \to (S) \\
        (0,1 & S & \$ & Accept & - \\
        \hline
        \end{array}
    \]
}

Tuttavia una domanda lecita è come si fa trovare questa tabella di parsing, bhe prima di presentarla occorre definire un automa dei prefissi variabili

\subsection{DFA a prefissi variabili}

\dfn{prefisso variabile}{
    un prefisso variabile è una stringa $\in (T\cup NT)^*$ che può apparire sulla pila di un parser bottom-up per una computazione che accetta un input
}

\dfn{prefisso viabile su una grammatica $G$ libera }{
    si definisce prefisso viabile su una grammatica $G$ libera una stringa $\gamma\in(T\cup NT)^* $ sse esiste una derivazione rightmost
    \[
        S\implies^* \delta A y \implies \delta \alpha \beta y = \gamma \beta y
    \]
    Dove: 
    \begin{itemize}
        \item $y\in T^*$
        \item $\delta\in (T\cup NT)^*$
        \item esiste una produzione $A\to \alpha \beta$
    \end{itemize}

    Inoltre $S$ è un prefisso variabile per definizione
}
\dfn{prefisso variabile completo e maniglia}{
    un prefisso viabile si dice completo se $\beta=\epsilon$, in tal caso $\alpha$ è detta maniglia per $\gamma y$
}
Dopo sta sborodolata di definizioni si possa al teorema che lega i prefissi variabili con i DFA:
\thm{}{
    Data $G$ libera, i prefissi viabili di $G$ costituiscono un linguaggio regolare e può essere descritto con un DFA. detto \textbf{DFA a prefissi viabili o automa canonico LR(0)}
}

Pertanto si ha questo corollario
\begin{corollary}
Il parser può consultare il DFA dei prefissi viabili (ovvero la tabella di parsing) per decidere cosa fare:
\begin{itemize}
    \item se la pila contiene un prefisso viabile completo il parser riduce
    \item se la pila contiene un prefisso viabile incompleto, allora il parser shifta
    \item se la pila non contiene un prefisso viabile, allora viene dato un errore
\end{itemize}  
\end{corollary}
In base a come è fatto questo DFA (che eventualmente può usare informazioni di look-ahead e dei follow) il parser può risultare deterministico o meno

Si noti, inoltre la seguente osservazione
\nt{
    si può dimostrare che un prefisso di un prefisso viabile è un prefisso viabile pertanto si ha che non è necessario ripartire da capo quando viene modificata la pila (ovvero il parser)
}

infatti la pila viene modificata in due modi:
\begin{enumerate}
    \item \textbf{shift}: la pila passa da $\$ \gamma$ a $\$\gamma x$. Dato che si trova in uno stato $s$ dopo aver elaborato un $\$\gamma$, occorre soltanto far ripartire il DFA da $S$ con input $x$
    \item la pila passa da $\$ \gamma\alpha$ a $\$ \gamma A$. Dato che si trova in uno stato $s$ dopo aver elaborato $\$ \gamma \alpha$, non c'è bisogno di far ripartire il DFA dalla base della pila, ma basta ripristinare lo stato in cui si trovava subito prima di elaborare il primo simbolo di $\alpha$ e fornirgli il simbolo $A$ in input
\end{enumerate}

Pertanto occorre lo stack degli stati del DFA!

Adesso introduciamo degli elementi fondamentali per l'automa canonico LR(0)

\subsection{Item LR(0)}

\dfn{Item $LR(0)$}{
    Un item $LR(0)$ è una produzione con indicata, con un punto, una posizione sulla sua parte destra
}

\esempio{
    La produzione $A\to XYZ$ genera 4 item diversi:
    \[
        \begin{array}{l}
            A\to .XYZ\\
            A\to X.YZ\\
            A\to XY.Z\\
            A\to XYZ.
        \end{array}
    \]
    In questo caso l'item $A\to .XYZ$ è un item iniziale
}

La posizione del ”.” indica no a dove abbiamo gia analizzato di questa produzione, per questo abbiamo che: 
\begin{itemize}
    \item Se l'item $A\to\alpha . \beta$ è nello stato attuale del DFA vuol dire che $\alpha$ è in cima sulla pila dei simboli e che stiamo aimo aspettando $\beta$
    \item Se invece abbiamo $A\to \alpha$. Vuol dire che abbiamo letto tutta la produzione e possiamo fare una reduce 
\end{itemize}

\subsection{Costruire l'NFA dei prefissi variabili}

Per costruire il DFA dei prefissi variabili occorre prima costruire il suo corrispettivo NFA.

Data $G=(NT, T, S, R)$ libera, l'NFA dei prefissi variabili di $G$ si costruisce partendo con un nuovo simbolo iniziale $S'$ ed una produzione $S' \to S$, inoltre;
\begin{itemize}
    \item $[S'\to .S]$ è lo stato iniziale 
    \item dallo stato $[A\to \alpha.X\beta]$ c'è una transizione dello stato $[A\to \alpha X.\beta]$ etichettata $X$, per $X\in T\cup NT$
    \item dallo stato $[A\to \alpha X. \beta]$, per $X\in NT$ e per ogni produzione $X\to \gamma$, c'è una $\epsilon$-transazione verso lo stato $[X\to .\gamma]$
\end{itemize}

\nt{
    non serve definire degli stati finali, perché l'NFA come ausilio al parser
}
\esempio{
    \[
        \begin{array}{l}
            S' \to S\\
            S\to (S) \\
            S\to ()
        \end{array}
    \]
    Tale grammatica mi diventa
    \[
        \begin{array}{l}
            S'\to .S\mid S.\\
            S\to .(S)\mid (.S)\mid (S.)\mid (S).\\
            S\to .()\mid (.)\mid ().
        \end{array}
    \]
    Ed il corrispettivo automa è:
    \begin{center}
        \begin{tikzpicture}[>=stealth, node distance=2.5cm, on grid, auto]

            % Stati
            \node[state, initial] (q0) {$S' \rightarrow \cdot S$};
            \node[state, above=of q0] (q1) {$S' \rightarrow S \cdot$};
            \node[state, below=of q0] (q2) {$S \rightarrow \cdot ()$};
            \node[state, below=of q2] (q6) {$S \rightarrow (\cdot  )$};
            \node[state, right=of q0] (q3) {$S \rightarrow \cdot(S)$};

            \node[state, right=of q3] (q4) {$S \rightarrow ( \cdot S  )$};
            \node[state, right=of q4] (q5) {$S \rightarrow ( S \cdot) $};
            \node[state, right=of q6] (q8) {$S \rightarrow ( ) \cdot$};
            \node[state, right=of q5] (q9) {$S \rightarrow (S) \cdot$};
            
            % Transizioni
            \path[->]
                (q0) edge node {$S$} (q1)
                     edge[bend left] node {$\varepsilon$} (q2)
                     edge node {$\epsilon$} (q3)
                (q2) 
                     edge node[left] {$($} (q6)
                (q3) edge[bend left] node {$($} (q4)
                (q4) edge[bend left] node {$\epsilon$} (q3)
                     edge[bend left] node {$S$} (q5)
                     edge[bend left] node {$\epsilon$} (q2)
                (q6) edge node {$)$} (q8)
                (q5) edge node {$)$} (q9)
            
        \end{tikzpicture}
    \end{center}
}

\section{Automa canonico $LR(0)$}
l'automa canonico $LR(0)$ è il DFA DFA dei prefissi viabili. Per ottenerlo ci sono due metodi:
\begin{itemize}
    \item Costruire prima l’NFA e poi con la costruzione di sooinsiemi oenere il DFA
    \item In un modo diretto usando due funzioni ausiliarle chiamate $clos(I)$ e $goto(I,X)$ dove $I$ è un insieme di item e $X\in T\cup NT$
\end{itemize}
\subsection{Costruzione diretta dell’automa canonico LR(0)}
Andiamo prima a definire le due funzioni $clos(I)$ e $goto(I,X)$:

\subsubsection{Clos()}
\begin{algorithm}
    \caption{$Clos()$}
    \KwIn{$I$}
    \KwOut{$I$}

    \While{$I$ non è più modificato}{
        \ForEach {item $A\to \alpha.X\beta \in I$}{
            \ForEach{ produzione $X\to \gamma$}{
                aggiungi $X\to ,\gamma$ ad $I$\;
            }
            
        }
    }
    \Return I\;
\end{algorithm}

Si può notare come aggiungo ad $I$  tui gli item che sarebbero stati raggiungibili nel NFA con mosse $\epsilon$
\subsubsection{Goto()}

\begin{algorithm}
    \caption{Goto}
    \KwIn{Insieme di item $I$ e $X\in (T\cup NT)$}
    \KwOut{Insieme $J$ di item completi}

    $J \gets \emptyset$\;
    \ForEach{ item $A\to \alpha. X\beta\in I$}{
        aggiungi $A\to aX.\beta$ a $J$\tcp*{scorre tutti i punti, creando un nuovo nodo dove il punto si è mosso}
    }
    \Return $clos(j)$ \tcp*{restituisce la closure del $j$ appena creato}
\end{algorithm}

ciao


\subsubsection{algoritmo per il lacolo del DFA LR(0)}
Date queste due funzioni adesso possiamo costruire l’automa DFA direamente:

\begin{algorithm}
    \caption{DFA LR(0)}
    $S \gets \{clos(\{S' \to .S\})\}$\;
    $\delta\gets \emptyset$\;
    \While{$S$ o $\delta$ non sono più modificati}{
        \ForEach{$I\in S$}{
            \ForEach{item $A\to \alpha.X\beta\in I$}{
                $J\gets Goto(I,X)$\;
                Aggiungi $J$ a $S$\;
                Aggiungi $\delta(I, X)\gets J$ a $\delta$\; 
            }
        }
    }
\end{algorithm}

% TODO INSERIRE DEGLI ESEMPI!!!!
\section{tabella di parsing LR}
\dfn{Tabella di parsing LR}{
    Si definisce la tabella di parsign LR una matrice bidimensionale $M$ tale che:
    \begin{itemize}
        \item le righe rappresentantano gli stati dell'automa canoninco LR(0)/LR(1)
        \item le colonne $T \cup\{\$\}\cup NT$
    \end{itemize}

    inoltre si ha che:
    \begin{itemize}
        \item $M[s,X]$ contiene le azioni che può compiere un parser LR con $S$ in cima alla pila degli stati e $x$ simbolo in inpu (o nonterminale)
        \item Se $M[s,X]$ è "bianca"/ vuota, allora ERRORE
        \item Se $M[s, X]$ contiene più automi, allora CONFLITTO
    \end{itemize}
}
\subsection{Riempire la tabella di parsing}
La tabella di parsing si riempe in base all’automa canonico LR(0). Per ogni stato $s$ va ripetuta la seguente cosa:
\begin{itemize}
    \item se $x\in T$ e $S\to t$ nell'automa $LR(0)$, inserisci shift in $M[s,x]$
    \item se $A\to \alpha.\in s$ e $A\neq S'$, inserisci reduce $A\to alpha$ in $M[s,x]$ per tutti gli $x\in T \cup\{\$\}$
    \item se $A\in NT$ e $S\tof$ nell'automa LR('), inserisci goto f
\end{itemize}

\dfn{Grammatica di classe LR(0)}{
    una grammatica viene definita di classe $LR(0)$ se ogni casella nella tabella di parsing $LR(0)$ contiene al più un elemento 
}

\section{Algoritmo del parser}
Il parser data la tabella di parsing LR esegue questo algoritmo per calcolare l’albero di derivazione. questo
algoritmo e per un generico parser LR (quindi funziona anche per $LR(k)$)
\begin{algorithm}
        \caption{Parser LR}
        Inizializza la pila con $\$ s_0$\;
        inizializza $i_c$ con il primo carattere in input\;
        \While{true}{
            $S\gets Top(pila)$\;
            \If{$M[S, i_c]== shift\text{ }t$ }{
                push $t$ sulla pila\;
                avanza $i_c$ sull'input\;
            }
            \If{$M[S, i_c]==accept$}{
                output("accept")\;
            }
            \If{$M[S, i_c] == reduce A\to \alpha$}{
                pop $|\alpha|$ stati dalla pila\;
                $s_1 \gets Top(pila)$\;
                $s_2 = M[s_1, A]$\;
                push $s_2$ sulla pila \tcp*{$s_2$ è lo stato dato al goto}
                output($A\to \alpha$)
            }
            \If{$M[S, i_c]==$" "}{
                errore()\tcp*{casella vuota}
            }
        }
\end{algorithm}