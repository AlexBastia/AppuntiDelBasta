\chapter{Bottom up parser}

Il \textbf{parser bottom up} è un tipo di analizzatore sintattico che che costruisce l'albero di derivazione partendo dalle foglie, viene anche detto \textbf{Shift-Reduce} in quanto possiede due operazioni fondamentali:
\begin{itemize}
    \item \texttt{Shift}: un simbolo terminale viene spostato dall'input alla pila 
    \item \texttt{Reduce}: una serie di simboli (terminali e non terminali) sulla cima della pila corrisponde al "reverse" di una parte destra di una produzione, ovvero:
    \[
        A\to\alpha \in R - \alpha^R \text{ sulla pila}
    \]
    La stringa $\alpha^T$ viene rimossa dalla pila e sostituita con $A$, quindi $\alpha$ viene ridotta ad $A$
\end{itemize}

Possono essere di diversi tipi

\section{Parser shift-reduce nondeterministico}
\begin{algorithm}
    \caption{Parser shift-reduce nondeterministico}
    \KwIn{Una grammatica libera $G$ con simbolo iniziale $S$ e una stringa $w\in T^*$}
    \KwOut{Una stringa $w\in T^*$}

    Inizializziamo la pila a $\$$\;
    Inizializziamo l'input con $w\$$\;
    usaimo il $PDA$ seguente per trovare la derivazione per $w\$$:
    \[
        M=(T, \{q\},\underbracket{T\cup NT \cup \{\$\}}_{\Gamma: \text{ovvero i simboli sulla pila}}, \delta, \varnothing)
    \]
    Dove:
    \begin{enumerate}
        \item $(q,aX)\in \delta (q,a,X)\forall A\in T\forall X\Gamma\quad \text{SHIFT}$
        \item $(q,A)\in\delta(q,\epsilon, \alpha^R)$ se $A\in \alpha\in R\quad \text{REDUCE}$
        \item $(q,\epsilon)\in \delta(q,\$,S\$)\quad \text{accept}$
    \end{enumerate}\;
    ogni volta che facciamo "reduce", forniamo in output la produzione usata\;
    alla fine, $S\$$ sulla pila, con $\$$ in input $\implies$ accettiamo\;
\end{algorithm}

\nt{
    generalizzazione della def. di $PDA$ dove non si consuma solo il top della pila, ma una serie di caratteri contigui a caminciare dal top
}

\esempio{
    Sia la seguente grammatica
    \[
        \begin{array}{l}
            E\to T\mid T+E \mid T-E\\
            T\to A\mid A*T\\
            A\to a\mid b\mid (E)
        \end{array}
    \]
    \[
        \begin{array}{|c|l|l|l|l|}
        \hline
        \textbf{N.} & \textbf{Pila} & \textbf{Input} & \textbf{Azione} & \textbf{Output} \\ \hline
        1  & \$                  & a+b*b\$              & Shift         &                 \\ \hline
        2  & \$a                & +b*b\$               & Reduce        & A \to a         \\ \hline
        3  & \$A                & +b*b\$               & Reduce        & T \to A         \\ \hline
        4  & \$T                & +b*b\$               & Shift         &                 \\ \hline
        5  & \$T+               & b*b\$                & Shift         &                 \\ \hline
        6  & \$T+b              & *b\$                 & Reduce        & A \to b         \\ \hline
        7  & \$T+A              & *b\$                 & Shift         &                 \\ \hline
        8  & \$T+A*             & b\$                  & Shift         &                 \\ \hline
        9  & \$T+A*b            & \$                   & Reduce        & A \to b         \\ \hline
        10 & \$T+A*B            & \$                   & Reduce        & T \to A * T     \\ \hline
        11 & \$T+A*T            & \$                   & Reduce        & E \to T + T     \\ \hline
        12 & \$E                & \$                   & Reduce        & E \to T + T     \\ \hline
        13 & \$E                & \$                   & Accept        &                 \\ \hline
        \end{array}
    \]

    Si ha che:
    \[
        E\implies T+E\implies T+T \implies T + A* T \implies T+A*A \implies T + A * b \implies T + b * b \implies A + b*b  \implies a + b*b
    \]

    Il cui albero è:
    \begin{center}
        \begin{tikzpicture}
            \Tree [
                .E
                [
                    .T
                    [
                        .A
                        [
                            .a
                        ]
                    ]
                ]
                [
                    .+
                ]
                [
                    .E
                    [
                        .T
                        [
                            .A
                            [
                                .b
                            ]
                        ]
                        [
                            .*
                        ]
                        [
                            .T
                            [
                                .A
                                [
                                    .b
                                ]
                            ]
                        ]
                    ]
                ]
            ]
        \end{tikzpicture}
    \end{center}
    
    Le cui proprietà sono:
    \begin{center}
        \item Costruzione dell'albero di derivazione \texttt{bottom-up}    
        \item Derivazione canonica a destra a rovescio
        \item forte non-determinismo:
        \begin{itemize}
            \item \textbf{conflitti shift-reduce}:
            \begin{itemize}
                \item $\$a \quad +b*b\$ \quad \text{shift}$
                \item $\$ a+ \quad b*b \$$
            \end{itemize}
            \item \textbf{Conflitti reduce-reduce}
            \begin{itemize}
                \item $\$T+A*T\quad\$$ reduce $E\to T$
                \item $\$T+A*E\quad\$$
            \end{itemize}
        \end{itemize}
    \end{center}
}

\nt{Si noti quindi che questo tipo parser genera moltissimi confilitti, in diverse sistuazioni era appunto possibile scegliere strade che non portano a riconoscere la stringa. F}

Per "risolvere" tale nondeterminismo occorre fornire al PDA una tabella parsing (struttura di controllo) che "aiuti" a scegliere l'azione giusta, ed è grazie all'uso di questa che nascono i cosiddetti \textbf{parser LR}

\section{Parser LR}
\dfn{Parser LR}{
    Il \textbf{parser LR} è un tipo di analizzatore sintattico che utilizza un approccio bottom-up per analizzare un input e verificare se appartiene al linguaggio generato da una grammatica libera. Il termine LR indica che:
    \begin{itemize}
        \item L: sta per \textit{left-to-right}: l'analisi dell'input avviene da sinistra a destra
        \item R: sta per \textit{Rightmost derivation}: l'analisi ricostruisce una derivazione più a destra in senso inverso
    \end{itemize}
}

Presento, qui uno schema bellino bellino:

%TODO DA FARE QUESTA GIGAMINCHIATA
\begin{center}
    \begin{tikzpicture}
        % Input
        \node at (-2.5, 3.5) {Input:};
        \node[stack] (input1) at (-1,0) {$a_1$};
        \node[stack, right of=input1] (input2) {$a_2$};



        % \node[stack] (input2) at (0,1) {$a_2$};
        % \node[stack] (dots) at (1, 2) {$\dots$};
        % \node[stack] (inputn) at (2,3) {$a_i$};
        % \node[stack] (end) at (3, 4) {$\dots$};
        % \node[stack] (end) at (4, 5) {$a_k$};
        % \node[stack] (end) at (5, 6) {$\$$};
    
        % Parser LR block
        \node[block] (parserLR) at (0,1.5) {Parser LR};
    
        % Output
        \node at (4.5, 1.5) {Output:};
        \node[align=center] (output) at (6.7,1.5) {Derivazione \\ \textit{rightmost} \\ = albero di derivazione};
    
        % Parsing Table
        \node[block] (table) at (0,-1.5) {Tabella di Parsing $M$ \\ \vspace{0.2cm} \textbf{Azione} (Shift/Reduce) \\ sui Terminali \\ \textbf{GOTO} sui Nonterminali};
    
        % Stack
        \node at (-4.2, 1.5) {Pila:};
        \node[stack] (stack0) at (-3.5,1.5) {$S_0$};
        \node[stack] (stackdots) at (-3.5,0.7) {$\vdots$};
        \node[stack] (stackn) at (-3.5,-0.1) {$S_m$};
    
        \node at (-4.2, -1.5) {Pila simboli:};
        \node[stack] (symbol0) at (-3.5,-1.5) {$X_0$};
        \node[stack] (symboldots) at (-3.5,-2.3) {$\vdots$};
        \node[stack] (symboln) at (-3.5,-3.1) {$X_m$};
    
        % Arrows
        \draw[arrow] (input1.south) -- (parserLR.north);
        \draw[arrow] (parserLR.south) -- (table.north) node[midway,right] {consulta};
        \draw[arrow] (parserLR.east) -- (output.west);
    
        \draw[arrow] (stack0.east) ++(0.2,0) -- (parserLR.west);
        \draw[arrow] (symbol0.east) ++(0.2,0) -- (parserLR.west);
    
        % DFA note
        \node[align=center] at (5,-2) {Generata a partire \\ da un DFA \\ (Automa canonico \\ degli stati \\ \textit{viabili})};
    \end{tikzpicture}    
\end{center}

dove una configurazione di tale parser è:
\[
    (s_0, \dots, s_n, x_1 \dots x_m, a_1 \dots a_k \$)
\]

\nt{
    $x_1 \dots x_m a_1 \dots a_k$ è una stringa intermedia della derivazione canonica destra
}
\subsection{Funzionamento del parsing LR}
il parser LR funzione nel seguente modo:
\begin{enumerate}
    \item Legge lo stato nel top della pila $s_n$ e il simbolo corrente dell'input $a_i$
    \item consulta la tabella di parsing LR $M[s_n, a_i]$
    \begin{itemize}
        \item Se $M[s_n, a_i] = \text{shift}\; s$, allora la nuova configurazione è:
        \[
            (s_0\dots s_n \underline{s}\;, x_1 \dots x_n \underline{a_i}, a_{i+1} \dots a_k \$)
        \]
        \item Se $M[s_n, a_i]= \underline{\text{reduce } A\to B}$, allora la nuova configurazione è
        
        \[
            (s_0 \dots s_{n-r} \underline{s}, x_1 \dots x_{m-r}A, a_i\dots a_k \$)
        \]
        Dove $r=|\beta|$ e $M[s_{n-r}, A]=goto \; \underline{s}$

        Cioè fa tre passi:
        \begin{enumerate}
            \item faccio "pop" di r elementi dai 2 stack
            \item metto A in cima alla pila dei simboli
            \item calcolo il nuovo stato top, guardando 
            \[
                M[s_{n-r}, A] = goto\; s \text{ e metto }s\text{ in cima alla pila degli stati}
            \]
        \end{enumerate}
        \item se $M[s_n, a_i] = accept \implies$ fine!
        \item se $M[s_n, a_i] = "bianco" \implies$ errore!
    \end{itemize}
\end{enumerate}
\esempio{
    Sia $G$ la seguente grammatica:
    \[
        \begin{array}{l}
            S'\to S\\
            Senza\to (S)\\
            S\to ()
        \end{array}
    \]

    % Tabella di Parsing LR(0)
    Assumendo che siamo già forniti di questa \textbf{Tabella di Parsing}

    \[
    \begin{array}{|c|ccc|c|}
    \hline
    \text{Stato} & \multicolumn{3}{c|}{\textbf{Azione}} & \textbf{Goto} \\
    \cline{2-4}
    & ( & ) & \$ & S \\
    \hline
    0 & S2 &  &  & g1 \\
    1 &  &  & \text{Accept} & g3 \\
    2 & S2 & S5 &  &  \\
    3 &  & S4 &  &  \\
    4 & r2 & r2 & r2 &  \\
    5 & r3 & r3 & r3 &  \\
    \hline
    \end{array}
    \]

    \vspace{0.5cm}

    % Seconda tabella: Stato della pila, input, azione e output
    \noindent\textbf{Esecuzione del Parsing}


    \[
        \begin{array}{|l|l|l|c|l|}
        \hline
        \text{Stato della pila} & \text{Stack simboli} & \text{Input} & \text{Azione} & \text{Output} \\
        \hline
        (0 & \varepsilon & (())\$ & S2 & - \\
        (0,2 & ( & ())\$ & S2 & - \\
        (0,2,2 & (( & ))\$ & S5 & - \\
        (0,2,2,5 & (() & )\$ & r3 & S \to () \\
        (0,2,3 & (S & )\$ & S4 & - \\
        (0,2,3,4 & (S) & \$ & r2 & S \to (S) \\
        (0,1 & S & \$ & Accept & - \\
        \hline
        \end{array}
    \]
}

Tuttavia una domanda lecita è come si fa trovare questa tabella di parsing, bhe prima di presentarla occorre definire un automa dei prefissi variabili

\subsection{DFA a prefissi variabili}

\dfn{prefisso variabile}{
    un prefisso variabile è una stringa $\in (T\cup NT)^*$ che può apparire sulla pila di un parser bottom-up per una computazione che accetta un input
}

\dfn{prefisso variabile su una grammatica $G$ libera }{
    si definisce prefisso variabile su una grammatica $G$ libera una stringa $\gamma\in(T\cup NT)^* $ sse esiste una derivazione rightmost
    \[
        S\implies^* \delta A y \implies \delta \alpha \beta y = \gamma \beta y
    \]
    Dove: 
    \begin{itemize}
        \item $y\in T^*$
        \item $\delta\in (T\cup NT)^*$
        \item esiste una produzione $A\to \alpha \beta$
    \end{itemize}

    Inoltre $S$ è un prefisso variabile per definizione
}
\dfn{prefisso variabile completo e maniglia}{
    un prefisso variabile si dice completo se $\beta=\epsilon$, in tal caso $\alpha$ è detta maniglia per $\gamma y$
}
Dopo sta sborodolata di definizioni si possa al teorema che lega i prefissi variabili con i DFA:
\thm{}{
    Data $G$ libera, i prefissi variabili di $G$ costituiscono un linguaggio regolare e può essere descritto con un DFA
}