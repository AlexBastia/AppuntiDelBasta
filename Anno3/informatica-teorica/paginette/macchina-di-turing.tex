% \begin{document}
\chapter{Macchine di Turing e Linguaggi}
\section{Linguaggi}

\subsection{Definizioni}

\dfn{Alfabeto}{

$ \Sigma = \{a,b,c,...\} $ e' l'\textit{alfabeto}


E' un insieme di simboli.
}

\dfn{Parola}{
$ w $ e' una parola o striga su $ \Sigma $ e' un concatenamento di 0 o piu' simboli di $ \Sigma $.
}

\dfn{Kleene}{
  def
}

\dfn{Linguaggio}{
  Sottoinsieme delle parole che si possono costruire su un determinato alfabeto $ \Sigma $:
  \[
  L \subseteq \Sigma^*
  \]
}

\dfn{}{
Dato un linguaggio $ L $ \textbf{fissato} per una stringa $ w $, decidere se:
\[
w \in L
\]
}

Il problema di appartenenza a un linguaggio $ L $ (\textbf{fissato!}) e' definito come:

dato il linguaggio $ L $, prendere in input una parola $ w $ e decidere se $ w \in L $.

input: stringa
output: booleano

Perche' vogliamo usare automi? : e' un formalismo piu' basico e piu' semplice da studiare rispetto a un arbitrario linguaggio di prorammazione.

\subsection{Automi}
Vabbe' introduce gli automi, il Guerriero ci ha gia preparato adeguatamente.

Alright whatsapp.

\section{Macchia di Turing}
Automa piu' potente che Turing si invento per studiare i problemi importanti da chiudere, fra cui l'automatizzazione dei teoremi.

E' nato per formalizzare il calcolo automatico in un tempo in cui non esistevano i computer, era la versione "automatizzata" di lui che scriveva su carta.

Iniziamo con una spiegazione informale:

E' una macchina caratterizzata da un nastro con delle cellette

In ognuna cella c'e' un simbolo, ed e' infinito in entrambe le direzioni

Ha una testina posizionata su una cella da cui puo' leggere il simbolo

La testina puo' spostarsi a dx o sx, e a differenza degli automi visti puo' benissio tornare indietro e cambiare la decisione presa prima (backtracking)

La testina puo' anche scrivere su una cella, perdendo cio' che c'era prima (una seconda differenza)

Per noi sta roba e' un algoritmo, dato che la macchina di Turing, in quanto automa, ha vari stati di funzionamento
\begin{itemize}
\item Legge simbolo cella
\item In base allo stato, sovrascrive qualcosa
\item Sposto la testina avanti o indietro
\item Cambio lo stato
\end{itemize}

\ex{}{
  Progetta una MdT che riconosca il linguaggio
  \[
  L = \{a^mb^m | m \geq 0\}
  \]
  La stringa da decidere si trova sul nastro da sx a dx e la testina si trova sopra il primo simbolo.

  Un algoritmo e' un filmato di quello che succede nella nostra testa per risolvere un problema.

  \begin{itemize}
    \item Leggi cella, se e' vuota fine (ok)
    \item altrimenti se e' $ b $ fine (no)
    \item se e' $ a $, cancella
    \item spostati a dx finche' la cella e' bianca
    \item vai a sx di uno e leggi
    \item se e' a, fine (no)
    \item se e' $ b $, cancella e vai a sx finche e' bianca
    \item muoviti di uno a dx
  \end{itemize}

  TODO: disegna automa
}

\subsection{Definizioni formali}
\dfn{Macchina di Turing}{
  E' la settupla
  \[
  M = \{Q, q_0, F, \Sigma, \Gamma, b/, \delta \}
  \]
  Dove:
  \begin{itemize}
  \item $ Q $ e' l'insieme di stati
  \item $ q_0 $ e' lo stato iniziale
  \item $ F $ e' l'insieme degli stati finali
  \item $ \Sigma $ e' l'insime dei simboli in input
  \item $ \Gamma $ e' l'insieme dei simboli che la macchina puo' scrivere $ \Sigma \subset \Gamma $
  \item $ b/ $ e' il simbolo di cella vuota ("blank") $ b/ \in \Gamma $
  \item $ \delta $ e' la funzione
    \[
    Q \times \Gamma \to Q \times \Gamma \times \{\gets, \to\}
    \]
  \end{itemize}
}

La macchina di turing ha stati finiti (come gli altri automi) e il suo programma e' fissato (non cambia). Quindi come fa a eseguire qualunque computazione? Vedremo.

  $ \delta $ codifica le funzioni di transizioni (gli archi dell'automa)

\dfn{Configurazione}{
  E' una "fotografia" dello stato corrente di computazione della macchina:
  \begin{itemize}
  \item Stato macchina
  \item Posizione testina
  \item Cosa c'e' sul nastro
  \end{itemize}
}

\ex{}{
  \[
  aq_1abb
  \]
  dove $ q_1 $ e' lo stato della macchina e la testina legge il carattere a dx dello stato.
  \[
  aabq_3b/
  \]
  sta leggendo la prima cella bianca a dx

  Nota: i caratteri bianchi ci permettono di precisare la posizione della testina, ma non ne dobbiamo mettere infiniti obv
}
Partendo dalla configurazione, usando la funzione di transizione siamo in grado di calcolare il passo che eseguira'

\dfn{Configurazione Accettante}{
  Quando al suo interno si trova uno stato accettante
}


\dfn{Legal Successor}{
  Data una MdT $ M $ e sia $ c_1 $ una sua configurazione, $ c_2 $ si dice \textit{legal successor} di $ c_1 $ sse:
  \[
  c_1 \vdash_M c_2
  \]
}
\dfn{Configurazione Finale}{
  Configurazione che non ha legal successor
}

\dfn{Computazione Parziale}{
  Data una MdT $ M $, una \textit{computazione parziale} per $ M $ e' una sequenza:
  \[
  c_1,c_2,...c_n
  \]
  dove
  \[
  c_1 \vdash_M c_2 \vdash_M ... \vdash_M c_n
  \]
}
\nt{
  Non e' detto che $ c_1 $ sia il punto di partenza e $ c_n $ sia l'ultima configurazione della configurazione, per questo e' parziale.
}

\dfn{Computazione}{
  Data una MdT $ M $ e una stringa $ w = w_1w_2...w_l $, una \textit{computazione} per $ M $ e' una computazione parziale per $ M $ dove
  \[
    c_1 = q_0w_1w_2...w_l 
  \]
  e $ c_n $ e' una configurazione finale
}

Possiamo ora definire quando una MdT accetta un input
\dfn{Accettazione}{
  Una MdT accetta $ w $ se si arresta su uno stato accettante, e rifuita $ w $ se non e' vero che si arresti in uno stato accettante.
}
\nt{
  Da questa definizione, se una MdT non si arresta allora l'input non e' accettato.
  Quindi per non accettare puo' anche divergere. Questa roba qua per noi e' un po' cringe.
}

\dfn{Linguaggio di una MdT}{
  Linguaggio 
  \[
    \mathcal{L}(M) = \{w | M(w) = 1\}
  \]

}

\dfn{Decide}{
  Sia $ L $ un linguaggio, $ M $ \textit{decide} $ L $ se $ \forall w \in \Sigma^* $
  \[
    w \in L \implies M \text{ accetta } w 
  \]
  \[ 
    w \notin L \implies M \text{ \textit{si arresta} e dice di "no" } w 
  \]
}

\dfn{Riconosce}{
  Sia $ L $ un linguaggio, $ M $ \textit{riconosce} $ L $ se $ \forall w \in \Sigma^* $
  \[
    w \in L \implies M \text{ accetta } w 
  \]
  \[ 
    w \notin L \implies M \text{ non accetta } w 
  \]
}

\subsection{Esercizi}
TODO: sarebbe figo fare gli automi in latex, se ho sbatti ci provo. Ah e alcune soluzioni sono imprecise le dovrei fixare.
\ex{}{
  \begin{center}
    \includegraphics[width=0.5\textwidth]{img/2026-02-20-16-21-46.png}
  \end{center}
}

\ex{}{
  \begin{center}
    \includegraphics[width=0.5\textwidth]{img/2026-02-20-16-42-06.png}
  \end{center}
}
\ex{}{
\begin{center}
  \includegraphics[width=0.5\textwidth]{img/2026-02-20-16-57-21.png}
\end{center}
}
\ex{}{
  \begin{center}
    \includegraphics[width=0.5\textwidth]{img/2026-02-22-11-23-06.png}
  \end{center}
}
\ex{}{
  \begin{center}
    \includegraphics[width=0.5\textwidth]{img/2026-02-22-11-33-47.png}
  \end{center}
}

\section{}
Le macchine che abbiamo visto finora sono molto tediose.

Per esempio, per riconoscere il linguaggio $ L = \{ww^R | w \in (0|1)^*\} $ e' stato necessario costruire due rami (uno per lo 0 e uno per l'1). Sarebbe comodo poter usare un solo ramo che in qualche modo codifica entrambe i rami, vediamo come possiamo fare:
\dfn{Memoria nello stato}{
  Data una MdT, si dice che questa ha \textbf{memoria} (nello stato) se ad ogni stato e' associata una memoria di uno o piu' simboli:
  \[
  \langle q_1, -, ..., - \rangle
  \]
  Il numero di simboli in memoria e' fissato, ovvero non puo' cambiare durante l'esecuzione.
}
\ex{}{
  Vogliamo riconoscere $ L = 10^*|01^* $
  \begin{center}
    \includegraphics[width=0.5\textwidth]{img/2026-02-26-12-17-39.png}
  \end{center}

  Notiamo che la macchina con memoria sopra non e' altro che una rappresentazione piu' compatta di una normale MdT con due rami al posto di uno. 
}
\mprop{Equipotenza macchine con memoria}{
  Data una MdT con memoria nello stato, e' sempre possibile costruire una MdT senza memoria che riconosce lo stesso linguaggio.
}
\pf{Dimostrazione}{
  Boh in verita' non dimostra sto risultato, dice solo che alla fine le macchine con memoria sono un prodotto cartesiano di stati con simboli.
}

\dfn{Macchine Multitraccia}{
  Multiple tracce lette in sincrono, la testina si muove tutta insieme ma possiamo leggere e scrivere singolarmente sulle tracce.
}
\ex{}{
  Vogliamo riconoscere $ L = \{w\#w | w \in (a|b)^+\} $:
  \begin{center}
    \includegraphics[width=0.5\textwidth]{img/2026-02-26-12-38-51.png}
  \end{center}
}
\mprop{Equipotenza macchine multitraccia}{
Data una macchina multitraccia, e' sempre possibile costruire una MdT classica che riconosce lo stesso linguaggio.
}
\pf{Dimostrazione}{
  Data una macchina multitraccia di $ n $ tracce con alfabeti $ \Gamma_i $ per ogni traccia $ i $, possiamo costruire una MdT con $ \Gamma = \Gamma_1 \times ... \times \Gamma_n $ che si comporta esattamente come la macchina multitraccia.
}

\dfn{Macchine Multinastro}{
  MdT che ha piu' nastri con testine indipendenti. Il numero dei nastri e' fissato a costruzione. E' possibile che una testina rimanga ferma.
}
\ex{}{
  Costruiamo la macchina multinastro che riconosce $ L = \{w | w \in (a|b|c)^* \land \text{ il numero delle a, b e c sono uguali}\} $. Vediamo l'idea:
  \begin{center}
    \includegraphics[width=0.5\textwidth]{img/2026-02-26-18-38-01.png}
  \end{center}
  Ora costruiamo l'automa:
  \begin{center}
    \includegraphics[width=0.5\textwidth]{img/2026-02-26-18-38-34.png}
  \end{center}
}
\mprop{Equipotenza di macchine multinastro}{
  Data una macchina multinastro, e' sempre possibile costruire una MdT classica che riconosce lo stesso linguaggio.
}
\pf{Dimostrazione}{
  Data una macchina multinastro e' possibile costruire una multitraccia equivalente con $ 2n $ tracce (dove $ n $ e' il numero dei nastri) semplicemente usando le tracce dispari come "puntatori" che indicano l'ipotetica posizione della testina, come se fosse multinastro.

  Ad ogni passo, collochiamo inizialmente la testina sul primo puntatore a sx per poi scansionare tutto fino all'ultimo puntatore. I simboli sotto ogni puntatore vengono salvati nella memoria, e la testina ritorna indietro cambiando in modo adeguato i simboli puntati e la posizione dei puntatori.
}
E' il modello di calcolo piu' flessibile che abbiamo a disposizione. Ma abbiamo visto che per simulare il suo comportamento con una macchina multitraccia impieghiamo piu' transizioni, ma quante di piu'?

\pf{Dimostrazione}{
  Analizziamo il caso peggiore dopo $ m $ passi. Questo avviene quando una testina della macchina si sposta a sx ad ogni passo e una si sposta a dx ad ogni passo, in modo che distino $ 2m $ celle. 

  Quindi una macchina multinastro avra' bisogno di percorrere due volte la distanza (passaggio in avanti e indietro) e deve poi aggiornare ogni puntatore (uno per ogni nastro), che nel caso peggiore comporta altre due transizioni.

  Alla fine abbiamo che un solo passo di una macchina multinastro ($ k $ nastri) richiede nel caso peggiore $ 4m + 2k $ passi di una macchina multitraccia.

  Possiamo quindi dire che una computazione che richiede $ n $ passi ad una macchina multinastro richiedera'
  \[
    \sum_{i=1}^{n} 4i + 2k \leq \sum_{i=1}^{n} 4n + 2k \leq n (4n + 2k)
  \]
  Quindi e' $ O(n^2) $.
}

\subsection{Esercizi}
\ex{}{
\begin{center}
  \includegraphics[width=0.5\textwidth]{img/2026-02-25-14-28-08.png}
\end{center}
}
\ex{}{
  \begin{center}
    \includegraphics[width=0.5\textwidth]{img/2026-02-25-14-57-04.png}
  \end{center}
}
\ex{}{
  \begin{center}
    \includegraphics[width=0.5\textwidth]{img/2026-02-25-14-56-16.png}
  \end{center}
}
\ex{}{
\begin{center}
  \includegraphics[width=0.5\textwidth]{img/2026-02-25-15-41-37.png}
\end{center}
}

\subsection{Macchine Non Deterministiche}
In verita' adesso introduciamo un altro tipo di macchina crazy che ci servira', vediamo un esempio:
\ex{}{
  \begin{center}
    \includegraphics[width=0.5\textwidth]{img/2026-02-27-15-17-51.png}
  \end{center}
  Notiamo che e' una macchina particolare perche' la sua funzione di transizione specifica un insieme di possibili passi data una configurazione.
}

\dfn{Macchina Non-deterministica}{
  $ N $ e' una macchina non-deterministica se e':
  \[
  N = \langle \Sigma, \Gamma, b\, Q, q_0, F, \delta \rangle
  \]
  dove $ \delta $ cambia rispetto alla classica macchina:
  \[
    \delta: Q \times \Gamma \to 2^{Q\times\Gamma\times \{\gets, \to\}}
  \]
}
\nt{
  Le macchine deterministiche sono un sottoinsieme degenere delle macchine non deterministiche dove l'immagine e' formata solo da insiemi di cardinalita' 1.
}

\ex{}{
  Supponiamo di voler vedere come funziona la macchina di prima su un input $ 01 $:
  \begin{center}
    \includegraphics[width=0.5\textwidth]{img/2026-02-27-15-37-02.png}
  \end{center}
  Ma accetta o rifuita?
}
Supponiamo di avere una bella MdT non-deterministica, cosa darebbe in output? Questa e' una domanda a trabocchetto perche' in verita' non potrebbe esistere (le macchine quantistiche sono meno potenti). Come vogliamo definire se una stringa e' accettata quindi?

Ci possiamo studiare l'\textit{albero di computazione}, che usa le configurazioni (che hanno significato analogo a quelle deterministiche) con le stesse definizioni di stato iniziale, finale e accettante, pero' cambiano i legal succesors.

Quindi i nodi sono tutte le configurazioni che una macchina non deterministica puo' provare processando la stringa $ w $.
La radice e' la config iniziale, e abbiamo un arco fra configurazioni $ a \to b $ se la config $ b $ e' legal successor della config $ a $.
Quindi la computazione e' un albero e non una lista.

La stringa $ w $ in input viene accettata quando nell'albero di computazione esiste almeno un percorso dalla radice a uno stato accettante.

Ma sta roba e' capace di riconoscere linguaggi che le macchine deterministiche non sono in grado di descrivere? 

\mprop{}{
  Una macchina di turing non deterministica ha lo stesso potere espressivo di quelle deterministiche.
}
\pf{}{
  La macchina non determinista $ N $ puo' essere ricondotta a una determinista $ M $
  \[
    N \longrightarrow M\ \mathcal{L}(N) = \mathcal{L}(M)
  \]

  Immaginiamo che $ N $ sia mononastro e $ M $ binastro.


  Stiamo esplorando l'albero in BFS dato che, se ci fosse una computazione infinita nell'albero e lo esploriamo in DFS, e' possibile che la macchina deterministica si "blocchi" a esplorare il ramo infinito quando forse puo' esserci un'altro ramo che in realta' e' accettante.
  
}

Ma questa simulazione quanto costa? 

Supponiamo che il numero massimo di figli nell'albero di computazione abbia al massimo $ c $ figli, allora in numero di nodi totali di un albero di altezza $ m $ e'
\[
  O(e^m)
\]
Quindi anche il costo per simulare la BFS di questo albero sara' esponenziale. Ma in realta' non siamo sicuri che questo sia il limite, e non siamo neanche stati in grado di dimostrare che questa cosa non e' possibile. P vs NP e' incentrata proprio su questa questione 

Ipotesi di Church-Turing:

Tutto cio' che e' calcolabile e' calcolabile da una macchina di Turing

E' self referential, non abbiamo una definizione di calcolabile, semplicemente non abbiamo sviluppato altri formalismi di calcolo con potere espressivo piu' alto. Quindi appunto non e' un teorema

Introduciamo le prime due classi di calcolabilita':
\begin{itemize}
  \item \textbf{RE}: ci sono tutti i linguaggi semi-decidibili, ovvero per i quali esiste una MdT che accetta (non decide) il linguaggio (potrebbe non terminare).
\item \textbf{R}: inclusa in RE, classe dei problemi di decisione ricorsivi (linguaggi ricorsivi), ovvero per i quali esiste una MdT  che quindi da' garanzia di risposta. Sono quindi linguaggi decidibili.
\end{itemize}

\dfn{Classe}{
  Semplicemente un insieme di linguaggi.
}

% \end{document}
