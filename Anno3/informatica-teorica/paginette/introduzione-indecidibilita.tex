% \begin{document}
\chapter{Introduzione a problemi e indecidibilita}

Studieremo due arie:
\begin{itemize}
  \item \textbf{Calcolabilita}: ci chiediamo se per quel problema esistera mai un algoritmo in grado di risolverlo (decidibilita' del problema). Non li incontriamo spesso irl dato che siamo piu' spinti a fare robe che sappiamo gestire. Bisogna studiare la struttura del problema per decidere se esiste o meno un algoritmo che lo risolve.
  \item \textbf{Complessita}: vogliamo determinare se un problema decidibile e' "facile" o "difficile", ovvero qual'e' la sua complessita' (diverso dalla complessita' degli algoritmi)
\end{itemize}

\nt{
  Il professore usa in modo informale i termini "facile" e "difficile" perche' si tratta solo di un'introduzione. Piu' avanti definiremo meglio questi concetti in base a se la complessita' e' \textit{polinomiale} o meno.
}

\dfn{Problema}{
  Relazione fra stringhe.
}

\ex{Somma}{
  Dati $ x $ e $ y $ calcola $ x + y \to z $. E' una relazione binaria fra stringhe:
  \begin{itemize}
    \item $ <(2,3), 5> $
    \item $ <(4,3), 7> $
    \\ \vdots
  \end{itemize}
  Dove la prima stringa e' l'input e la seconda e' l'output. Dato che elencare tutte le tuple e' impossibile, le descriviamo a parole ma stando attenti ad essere precisi. Ci servono tre elementi:
  \begin{itemize}
  \item What is input?
  \item What is output?
  \item Che relazione c'e' fra out e in?
  \end{itemize}
}

\section{Halting Problem}
Definiamo prima per bene il problema:
\begin{itemize}
\item Input: Una stringa $ P $ che rapresenta il codice sorgente di un programma
\item Output: Un booleano
\item Relazione: Se $ P $ termina ritorna T, altrimenti F
\end{itemize}

Sembra un problema semplice, ma vedremo che in realta' e' indecidibile. Per confermare cio' dobbiamo formulare una dimostrazione formale, usando quel che viene chiamato "metodo diagonale".

Il prof non va cosi' in dettaglio per il metodo usato nella dimostrazione (dato che e' solo un esempio introduttivo), ma secondo me e' interessante e fornisce un bell'esempio per l'utilita' della Teoria delle Categorie.

\subsection{Il Metodo Diagonale}
Il \textit{metodo diagonale} e' uno schema utile per la dimostrazione di certi teoremi. E' stato ideato per la prima volta da Cantor per dimostrare, per esempio, che $ \mathbb{R} $ non e' numerabile, dove viene usata la \textit{diagonale} di una tabella per dimostrare un assurdo. Questo metodo e' stato successivamente usato per dimostrare altre proposizioni molto importanti, come il teorema di Cantor (quello sugli insiemi potenza), il paradosso di Russel e i teoremi dell'incompletezza di Godel.

La struttura della dimostrazione generale e' la seguente:
\begin{center}
  \includegraphics[width=0.5\textwidth]{img/2026-02-17-11-46-41.png}
\end{center}
Lo schema e' molto astratto, e' formato solo da \textit{punti} (i vertici) e \textit{frecce} che possono essere composte per formare altre frecce. I primi possono essere insiemi e le frecce funzioni, come vedremo. Le quattro frecce hanno delle funzioni particolari:
\begin{itemize}
  \item La funzione "potente" $ X $: nella Teoria delle Categorie viene definita \textit{morfismo punto-suriettivo}(?). E' la freccia che assumiamo esista per poi dimostrare l'assurdo.
  \item La funzione diagonale $ D $: dato un elemento $ x $ ritorna la coppia $ (x,x) $. Raccoglie l'essenza del metodo diagonale in quanto e' la componente che causa l'\textit{auto-referenzialita'} che sta al cuore della dimostrazione.
  \item La funzione che inverte $ I $: dato l'output di $ X $ lo \textit{inverte} in modo da causare l'assurdita'.
  \item La funzione "speciale" $ S  $: composizione delle tre frecce sopra, insieme all'assunzione iniziale permette di dimostrare l'assurdo.
\end{itemize}

\nt{ Lowkey non l'ho spiegato benissimo dato che non ho studiato abbastanza le sue applicazioni e so solo le basi della Teoria delle Categorie quindi non e' rigoroso per niente. Forse nel futuro ci ritornero', boh.}

Finita la costruzione, i prossimi passi sono:
\begin{enumerate}
\item Codifica $ S  $ con una \textit{COSA}, $ k $.
\item Cosa succede se passo $ k $ a $ S  $?
\end{enumerate}

\nt{In verita' non sono sicurissimo se questi passi fanno parte del metodo generale o solo dell'halting}

\subsection{Dimostrazione Halting Problem}
Andiamo ora a vedere come puo' essere dimostrato che l'halting problem e' indecidibile.

Per prima cosa dobbiamo definire la controparte concreta delle frecce e punti dello schema:
\begin{itemize}
\item I punti \textit{COSE} sono insiemi di tutti i programmi o dati possibili. Sfruttando la \textbf{Numerazione di Godel} possiamo attribuire a ognuno di questi un numero naturale. Quindi \textit{COSE} diventa $ \mathbb{N} $.
\item I punti \textit{VALORI} sono tutti i possibili output di un programma, quindi dei dati. Quindi \textit{VALORI} diventa $ \mathbb{N} $.
\item La freccia $ X $ diventa il programma \textit{HALT}, ovvero la funzione totale che prende un \textit{Programma} $ P $ e un \textit{Dato} $ D $ (entrambe $ \in \mathbb{N} $) tale che:
  \[
    X(P,D) = \begin{cases}
    \text{"termina"} & P \text{ termina su } D\\
    \text{"diverge"} & P \text{ non termina su } D
    \end{cases}
  \]
  Per ora assumiamo l'esistenza di questo programma.
\item La freccia $ D $ e' il programma che implementa la funzione totale $ \mathbb{N} \to \mathbb{N} \times \mathbb{N} $
  \[
    D(x) = (x,x)
  \]
  che e' facile da costruire e quindi esiste.
\end{itemize}
\begin{center}
  \includegraphics[width=0.5\textwidth]{img/2026-02-17-23-12-59.png}
\end{center}
Non e' chiaro come dobbiamo definire $ I $ in modo da dimostrare l'assurdo, quindi lavoriamo top-down.

Dato che una composizione di programmi e' un programma, anche $ S  $ e' sicuramente un programma, quindi una funzione parziale che puo' terminare o divergere dato un input.

Essendo $ S  $ un programma, e' possibile rappresentarlo con un numero $ k \in \mathbb{N} $. Analizziamo $ S(k) $:
\begin{itemize}
  \item $ S(k) $ termina: in questo caso $ X(k,k) = \text{"termina"} $, quindi $ S(k) = I(\text{"termina"}) $. Per rimanere coerente $ I $ deve terminare sull'input "termina".
  \item $ S(k) $ non termina: in questo caso $ X(k,k) = \text{"diverge"} $, quindi $ S(k) = I("diverge") $. Per rimanere coerente $ I $ deve divergere sull'input "diverge".
\end{itemize}

Ma noi non vogliamo la coerenza, vogliamo costruire $ S  $ in modo da dimostrare l'assurdo. Quindi definiamo $ I $ come la funzione parziale che:
\begin{itemize}
\item Diverge sull'input "termina"
\item Termina sull'input "diverge"
\end{itemize}

Abbiamo quindi che:

\begin{itemize}
  \item Se $ X(k,k) = \text{"termina"} $, allora $ S(k) $ diverge
  \item Se $ X(k,k) = "diverge" $, allora $ S(k) $ termina
\end{itemize}

Queste due implicazioni sono in opposizione alla definizione del programma \textit{HALT}, che quindi non puo' esistere.

\section{Tipi di problemi}

Ci sono due categorie:
\begin{itemize}
\item \textbf{Ricerca}: vogliamo calcolare un risultato arbitrario, ovvero \textit{ricercano} un output vario.
\item \textbf{Decisione}: l'output e' \textit{booleano}.
\end{itemize}

Queste due tipologie non sono completamente sganciate, esiste una relazione.

Dato un problema di ricerca, possiamo ricavare la versione "decisionale" che e' piu' facile da calcolare.

\ex{Somma}{
  Ricerca: dati $ a,b $ calcolare la somma $ c = a + b $.

  Decisione: dati $ a,b,c $ determinare se $ c = a + b $ (vero o falso).
}

Per questo motivo parleremo quasi totalmente solo di problemi di decisione.

\nt{
  E' da qui che deriva il termine "decidibile".
}

\subsection{Problemi di decisione}
\thm{}{
  Tutti i problemi di decisione possono essere ridotti al riconoscimento di uno specifico linguaggio.
}

\ex{}{
  PATH $ <G,s,t> $: vogliamo stabilire se esiste un percorso da $ s  $ a $ t $.

  Mostriamo di poter trasformare questo problema decisionale in un problema che chiede se una "parola" appartiene a uno specifico linguaggio.

  \[
  L_{\text{PATH}} = \{<G,s,t> | G \text{ e' un Grafo } \land s,t \text{ sono nodi del grafo } G \land \exists \text{ un percorso da } s \to t\}
  \]

  Ci riduciamo quindi a decidere se una data tripla appartiene a $ L_{\text{PATH}} $ o meno.
}

Quindi, mentre studiamo decidibilita' dei problemi guarderemo linguaggi e i loro \textit{automi}.

\section{Linguaggi}

\subsection{Definizioni}

\dfn{Alfabeto}{

$ \Sigma = \{a,b,c,...\} $ e' l'\textit{alfabeto}


E' un insieme di simboli.
}

\dfn{Parola}{
$ w $ e' una parola o striga su $ \Sigma $ e' un concatenamento di 0 o piu' simboli di $ \Sigma $.
}

\dfn{Kleene}{
  def
}

\dfn{Linguaggio}{
  Sottoinsieme delle parole che si possono costruire su un determinato alfabeto $ \Sigma $:
  \[
  L \subseteq \Sigma^*
  \]
}

\dfn{}{
Dato un linguaggio $ L $ \textbf{fissato} per una stringa $ w $, decidere se:
\[
w \in L
\]
}

Il problema di appartenenza a un linguaggio $ L $ (\textbf{fissato!}) e' definito come:

dato il linguaggio $ L $, prendere in input una parola $ w $ e decidere se $ w \in L $.

input: stringa
output: booleano

Perche' vogliamo usare automi? : e' un formalismo piu' basico e piu' semplice da studiare rispetto a un arbitrario linguaggio di prorammazione.

\subsection{Automi}
Vabbe' introduce gli automi, il Guerriero ci ha gia preparato adeguatamente.

Alright whatsapp.

\subsection{Macchia di Turing}
Automa piu' potente che Turing si invento per studiare i problemi importanti da chiudere, fra cui l'automatizzazione dei teoremi.

E' nato per formalizzare il calcolo automatico in un tempo in cui non esistevano i computer, era la versione "automatizzata" di lui che scriveva su carta.

Iniziamo con una spiegazione informale:

E' una macchina caratterizzata da un nastro con delle cellette

In ognuna cella c'e' un simbolo, ed e' infinito in entrambe le direzioni

Ha una testina posizionata su una cella da cui puo' leggere il simbolo

La testina puo' spostarsi a dx o sx, e a differenza degli automi visti puo' benissio tornare indietro e cambiare la decisione presa prima (backtracking)

La testina puo' anche scrivere su una cella, perdendo cio' che c'era prima (una seconda differenza)

Per noi sta roba e' un algoritmo, dato che la macchina di Turing, in quanto automa, ha vari stati di funzionamento
\begin{itemize}
\item Legge simbolo cella
\item In base allo stato, sovrascrive qualcosa
\item Sposto la testina avanti o indietro
\item Cambio lo stato
\end{itemize}

\ex{}{
  Progetta una MdT che riconosca il linguaggio
  \[
  L = \{a^mb^m | m \geq 0\}
  \]
  La stringa da decidere si trova sul nastro da sx a dx e la testina si trova sopra il primo simbolo.

  Un algoritmo e' un filmato di quello che succede nella nostra testa per risolvere un problema.

  \begin{itemize}
    \item Leggi cella, se e' vuota fine (ok)
    \item altrimenti se e' $ b $ fine (no)
    \item se e' $ a $, cancella
    \item spostati a dx finche' la cella e' bianca
    \item vai a sx di uno e leggi
    \item se e' a, fine (no)
    \item se e' $ b $, cancella e vai a sx finche e' bianca
    \item muoviti di uno a dx
  \end{itemize}

  TODO: disegna automa
}

\subsubsection{Definizioni formali}
\dfn{Macchina di Turing}{
  E' la settupla
  \[
  M = \{Q, q_0, F, \Sigma, \Gamma, b/, \delta \}
  \]
  Dove:
  \begin{itemize}
  \item $ Q $ e' l'insieme di stati
  \item $ q_0 $ e' lo stato iniziale
  \item $ F $ e' l'insieme degli stati finali
  \item $ \Sigma $ e' l'insime dei simboli in input
  \item $ \Gamma $ e' l'insieme dei simboli che la macchina puo' scrivere $ \Sigma \subset \Gamma $
  \item $ b/ $ e' il simbolo di cella vuota ("blank") $ b/ \in \Gamma $
  \item $ \delta $ e' la funzione
    \[
    Q \times \Gamma \to Q \times \Gamma \times \{\gets, \to\}
    \]
  \end{itemize}
}

La macchina di turing ha stati finiti (come gli altri automi) e il suo programma e' fissato (non cambia). Quindi come fa a eseguire qualunque computazione? Vedremo.

  $ \delta $ codifica le funzioni di transizioni (gli archi dell'automa)

\dfn{Configurazione}{
  E' una "fotografia" dello stato corrente di computazione della macchina:
  \begin{itemize}
  \item Stato macchina
  \item Posizione testina
  \item Cosa c'e' sul nastro
  \end{itemize}
}
\ex{}{
  \[
  aq_1abb
  \]
  dove $ q_1 $ e' lo stato della macchina e la testina legge il carattere a dx dello stato.
  \[
  aabq_3b/
  \]
  sta leggendo la prima cella bianca a dx

  Nota: i caratteri bianchi ci permettono di precisare la posizione della testina, ma non ne dobbiamo mettere infiniti obv
}
Partendo dalla configurazione, usando la funzione di transizione siamo in grado di calcolare il passo che eseguira'

\dfn{Configurazione Accettante}{
  Quando al suo interno si trova uno stato accettante
}


\dfn{Legal Successor}{
  Data una MdT $ M $ e sia $ c_1 $ una sua configurazione, $ c_2 $ si dice \textit{legal successor} di $ c_1 $ sse:
  \[
  c_1 \vdash_M c_2
  \]
}
\dfn{Configurazione Finale}{
  Configurazione che non ha legal successor
}

\dfn{Computazione Parziale}{
  Data una MdT $ M $, una \textit{computazione parziale} per $ M $ e' una sequenza:
  \[
  c_1,c_2,...c_n
  \]
  dove
  \[
  c_1 \vdash_M c_2 \vdash_M ... \vdash_M c_n
  \]
}
\nt{
  Non e' detto che $ c_1 $ sia il punto di partenza e $ c_n $ sia l'ultima configurazione della configurazione, per questo e' parziale.
}

\dfn{Computazione}{
  Data una MdT $ M $ e una stringa $ w = w_1w_2...w_l $, una \textit{computazione} per $ M $ e' una computazione parziale per $ M $ dove
  \[
    c_1 = q_0w_1w_2...w_l 
  \]
  e $ c_n $ e' una configurazione finale
}

Possiamo ora definire quando una MdT accetta un input
\dfn{Accettazione}{
  Una MdT accetta $ w $ se si arresta su uno stato accettante, e rifuita $ w $ se non e' vero che si arresti in uno stato accettante.
}
\nt{
  Da questa definizione, se una MdT non si arresta allora l'input non e' accettato.
  Quindi per non accettare puo' anche divergere. Questa roba qua per noi e' un po' cringe.
}

\dfn{Linguaggio di una MdT}{
  Linguaggio 
  \[
    \mathcal{L}(M) = \{w | M(w) = 1\}
  \]

}

\dfn{Decide}{
  Sia $ L $ un linguaggio, $ M $ \textit{decide} $ L $ se $ \forall w \in \Sigma^* $
  \[
    w \in L \implies M \text{ accetta } w 
  \]
  \[ 
    w \notin L \implies M \text{ \textit{si arresta} e dice di "no" } w 
  \]
}

\dfn{Riconosce}{
  Sia $ L $ un linguaggio, $ M $ \textit{riconosce} $ L $ se $ \forall w \in \Sigma^* $
  \[
    w \in L \implies M \text{ accetta } w 
  \]
  \[ 
    w \notin L \implies M \text{ non accetta } w 
  \]
}

\subsubsection{Esercizi}
\ex{}{
  \begin{center}
    \includegraphics[width=0.5\textwidth]{img/2026-02-20-16-21-46.png}
  \end{center}
}

\ex{}{
  \begin{center}
    \includegraphics[width=0.5\textwidth]{img/2026-02-20-16-42-06.png}
  \end{center}
}
\ex{}{
\begin{center}
  \includegraphics[width=0.5\textwidth]{img/2026-02-20-16-57-21.png}
\end{center}
}
% \end{document}
